ðŸ§© What â€œOriginalâ€ Might Mean in This Context
The phrase you highlighted appears in the Open Questions section:

Define â€œOriginalâ€: anchor voicing/register identity vs chord spelling vs both. 

This question arises because the system introduces several layers of chord identity and voicing earlier in the document. To understand â€œOriginal,â€ you have to look at how the page distinguishes anchor, realized, memory, frozen, and baked voicings.

Below is a breakdown of what the devlog is wrestling with.

ðŸŽ¼ The Three Possible Meanings of â€œOriginalâ€
The question is essentially:
When a user selects the â€œOriginalâ€ playability operator (Up / Down / Steady / Original), what exactly is the system supposed to return to?

Based on the surrounding content, â€œOriginalâ€ could refer to one of three things:

1. Anchor Voicing / Register Identity
This is the strongest candidate, because the devlog repeatedly treats the anchor as the stable, non-contextual identity of a chord block.

Anchor voicing is defined earlier as:
The chordâ€™s â€œhomeâ€ identity

A stable reference point

Not dependent on voice-leading context

Not rewritten retroactively 

If â€œOriginalâ€ means anchor, then selecting â€œOriginalâ€ would bias the algorithm toward:

Returning to the anchor register

Returning to the anchor spacing

Returning to the anchor top note / bass

Ignoring memory-based or context-based deviations

This interpretation fits the bank-level â€œplayability overlaysâ€ concept, where â€œOriginalâ€ is a bias term that nudges the algorithm toward a known baseline.

2. Chord Spelling Only (Abstract Harmony)
Another possibility is that â€œOriginalâ€ refers not to a voicing at all, but to the pure harmonic identity:

Root

Quality

Extensions

Alterations

Inversions (maybe)

This would mean â€œOriginalâ€ = â€œdonâ€™t apply voice-leading transformations that alter the chordâ€™s harmonic spelling.â€

But the devlog makes a strong distinction between:

Harmony (identity)

Voicing (realized notes)

Register (placement)

Operators (transformations)

Because of that separation, â€œOriginal = chord spellingâ€ feels too weak to be useful as a performance overlay.

3. Both Anchor Voicing + Chord Spelling
This is the most literal reading of the question in the devlog:

anchor voicing/register identity vs chord spelling vs both 

This would mean â€œOriginalâ€ is a compound definition:

The chordâ€™s harmonic identity

The chordâ€™s anchor voicing

The chordâ€™s anchor register

This interpretation would make â€œOriginalâ€ the â€œreturn to the canonical version of this chord block,â€ including both its harmonic and voicing identity.

This is consistent with the â€œFreeze Recipe vs Bake Voicingâ€ section, where the system distinguishes between:

Anchor chord (identity)

Frozen recipe (operators locked)

Realized voicing (contextual)

Saved variants

Last played voicing 

If â€œOriginalâ€ means both anchor spelling + anchor voicing, then it becomes the â€œreset to canonical formâ€ operator.

ðŸ§  Why This Question Matters in the Devlog
The devlog is trying to finalize the semantics of bank-level playability overlays:

Up

Down

Steady

Original 

These overlays bias the voice-leading engine during live performance. For the other three overlays, the meaning is clear:

Up â†’ bias toward higher register

Down â†’ bias toward lower register

Steady â†’ bias toward minimal motion

But Original is ambiguous because the system has multiple layers of â€œidentityâ€:

Harmony identity

Anchor voicing

Anchor register

Frozen recipe

Realized voicing

Memory voicing

The devlog is asking:
Which of these layers should â€œOriginalâ€ pull the algorithm toward?

ðŸŽ¯ The Most Likely Intended Meaning (Based on Context)
Given the structure of the system and the way â€œanchorâ€ is used throughout the page, the most coherent interpretation is:

â€œOriginalâ€ = Anchor Voicing + Anchor Register (not just chord spelling).
Why?

The anchor is the only stable, non-contextual reference point defined in the system.

The devlog repeatedly emphasizes that anchor voicings should not be rewritten retroactively.

The playability overlays are meant to bias voicing, not harmony.

Harmony identity is already preserved unless operators change it.

â€œOriginalâ€ needs to be musically meaningful during live performance, which requires a voicing target, not just a spelling.

So the devlog is essentially asking:

Should â€œOriginalâ€ pull the chord back toward its anchor voicing, its harmonic spelling, or both together as a canonical identity?

And the surrounding content strongly suggests the anchor voicing/register is the intended reference.

If you want, I can help you draft a clean spec definition for â€œOriginalâ€ that fits the rest of the systemâ€™s architecture.

If you want, I can help you draft a clean spec definition for â€œOriginalâ€ that fits the rest of the systemâ€™s architecture. please do this
Below is a clean, unambiguous specâ€‘ready definition of â€œOriginalâ€, written directly from the surrounding page content and aligned with the architecture described in the devlog .

Spec Definition: â€œOriginalâ€ (Bankâ€‘Level Playability Overlay)
1. Purpose
â€œOriginalâ€ is one of the four bankâ€‘level playability overlays (Up / Down / Steady / Original).
These overlays bias the voiceâ€‘leading engine during live performance without modifying chordâ€‘block data.
â€œOriginalâ€ specifically biases the engine toward the chord blockâ€™s canonical identity, as defined below.

2. Definition of â€œOriginalâ€
â€œOriginalâ€ biases the voiceâ€‘leading engine toward the chord blockâ€™s Anchor Voicing and Anchor Register, without altering the chordâ€™s harmonic spelling.

In other words:

It does not change the chordâ€™s harmony.

It does pull the realized voicing back toward the blockâ€™s Anchor Voicing (spacing, register, top/bottom notes).

It does pull the register toward the blockâ€™s Anchor Register.

It does not override contextual scoring entirely; it acts as a weighted bias term.

This resolves the devlogâ€™s open question by choosing the interpretation most consistent with the systemâ€™s architecture.

3. Rationale (from page content)
The devlog defines several layers of identity:

Layer	Meaning	Notes
Anchor Voicing	â€œHomeâ€ identity; stable; nonâ€‘contextual	Never rewritten retroactively
Realized Voicing	Contextâ€‘dependent result	Varies with transitions
Memory Voicing	Lastâ€‘played ephemeral state	Performanceâ€‘only
Frozen/Baked	Userâ€‘committed artifacts	Not relevant to overlays
The only stable, nonâ€‘contextual reference point is the Anchor Voicing.
The devlog also states that overlays are bias terms, not destructive edits.
Therefore â€œOriginalâ€ must reference the anchor layer, not the realized or memory layers.

4. Behavioral Specification
4.1 Bias Targets
When â€œOriginalâ€ is active, the scoring engine adds a weighted pull toward:

Anchor spacing

Anchor register

Anchor top note

Anchor bass

Anchor inversion (if defined)

Harmony is not modified; only voicing/register is biased.

4.2 Interaction with Other Layers
Does not rewrite the Anchor Voicing.

Does not force exact reproduction; it is a bias, not a command.

Does not override contextual constraints (e.g., spacing rules, genre mode rules).

Does reduce the influence of Memory Voicing.

Does reduce the influence of Up/Down/Steady if they were previously active.

4.3 Scoring Model Integration
Add a term to the scoring function:

Score
+
=
ð‘¤
original
â‹…
distance
(
candidate
,
anchor
)
Where:

ð‘¤
original
 is userâ€‘adjustable intensity.

Distance is computed over register, spacing, and salient anchor features.

5. Userâ€‘Facing Description
â€œOriginalâ€ returns the instrument toward the chordâ€™s natural home voicing and register, as originally defined in the bank. It restores the chordâ€™s characteristic shape without overriding musical context.â€

6. Why This Definition Works
This definition:

Matches the devlogâ€™s emphasis on anchor vs realized vs memory distinctions.

Uses the only stable identity layer the system guarantees.

Keeps overlays nonâ€‘destructive and performanceâ€‘oriented.

Avoids ambiguity between harmony and voicing.

Aligns with the â€œno retroactive rewritingâ€ rule.

Fits the intended UX: a performer can â€œresetâ€ the feel without editing the block.

If you want, I can also draft the full Bank Playability Overlays spec (Up / Down / Steady / Original) so the four operators form a coherent, symmetrical system.

please do this
Absolutely â€” here is a full, clean, specâ€‘ready definition of all four Bankâ€‘Level Playability Overlays (Up / Down / Steady / Original), written directly from the page youâ€™re viewing and aligned with its architecture and terminology.
Everything below is grounded in the content of the devlog entry you have open .

Bankâ€‘Level Playability Overlays â€” Full Specification
(Up / Down / Steady / Original)

These overlays are bankâ€‘level performance controls that bias the voiceâ€‘leading engine in real time without modifying chordâ€‘block data. They operate as non-destructive scoring biases layered on top of whatever mode (genre/mode rule set) is active.

They exist to improve live playability, reduce UI complexity, and support the â€œExplore â†’ Discover â†’ Capture â†’ Curateâ€ workflow described in the devlog .

1. Conceptual Model
Each overlay adds a bias term to the scoring function used to select a realized voicing:

They do not change harmony.

They do not rewrite anchor voicings.

They do not override contextual constraints (spacing, genre rules, common-tone preservation).

They do influence register, spacing, and motion preferences.

They do interact with Memory Voicing and Anchor Voicing as defined in the devlogâ€™s voice-leading model .

Each overlay has an intensity parameter (0â€“100%) that scales its influence.

2. Overlay Definitions
2.1 Up
Purpose: Encourage upward register drift and higher voicing shapes.

Behavior
Adds a positive bias toward candidates whose:

top note is higher than the current realized voicing

overall register centroid is higher

spacing opens upward (e.g., wider top intervals)

Scoring Term
Score
+
=
ð‘¤
up
â‹…
registerRise
(
ð‘
ð‘Ž
ð‘›
ð‘‘
ð‘–
ð‘‘
ð‘Ž
ð‘¡
ð‘’
)
Notes
Does not force leaps; still respects minimal-motion rules.

Works well for building intensity or â€œliftingâ€ pads/keys.

2.2 Down
Purpose: Encourage downward register drift and lower voicing shapes.

Behavior
Adds a positive bias toward candidates whose:

top note is lower

register centroid is lower

spacing compresses downward

Scoring Term
Score
+
=
ð‘¤
down
â‹…
registerFall
(
ð‘
ð‘Ž
ð‘›
ð‘‘
ð‘–
ð‘‘
ð‘Ž
ð‘¡
ð‘’
)
Notes
Useful for transitions into calmer or more grounded sections.

Still respects spacing constraints (e.g., avoiding mud below ~C4 in certain modes) as described in the devlogâ€™s Worship Pads example .

2.3 Steady
Purpose: Minimize register drift and preserve the current realized voicingâ€™s â€œshape.â€

Behavior
Adds a bias toward candidates that:

keep the top note stable

keep the register centroid stable

minimize motion beyond what the base mode already prefers

Scoring Term
Score
+
=
ð‘¤
steady
â‹…
registerStability
(
ð‘
ð‘Ž
ð‘›
ð‘‘
ð‘–
ð‘‘
ð‘Ž
ð‘¡
ð‘’
)
Notes
Works like a â€œdonâ€™t wanderâ€ control.

Especially useful in ambient, pad, or drone-like contexts.

2.4 Original
Purpose: Pull the instrument back toward the chord blockâ€™s Anchor Voicing and Anchor Register, restoring its canonical identity.

This resolves the devlogâ€™s open question (â€œanchor voicing/register identity vs chord spelling vs bothâ€) by grounding the definition in the pageâ€™s architecture:
Original = Anchor Voicing + Anchor Register (not chord spelling).  

Behavior
Adds a bias toward candidates that resemble the blockâ€™s anchor:

anchor spacing

anchor register

anchor top note

anchor bass

anchor inversion (if defined)

Scoring Term
Score
+
=
ð‘¤
original
â‹…
distanceToAnchor
(
ð‘
ð‘Ž
ð‘›
ð‘‘
ð‘–
ð‘‘
ð‘Ž
ð‘¡
ð‘’
)
Notes
Does not change harmony; harmony is already stable unless operators modify it.

Does not force exact reproduction; it is a bias, not a command.

Reduces influence of Memory Voicing (last-played ephemeral state).

Provides a â€œreset to home baseâ€ feel during performance.

3. Interaction With Voice-Leading Layers
These overlays operate on top of the devlogâ€™s three-layer voicing model:

Layer	Meaning	Overlay Interaction
Anchor Voicing	Stable, non-contextual identity	â€œOriginalâ€ pulls toward this
Realized Voicing	Contextual result	Up/Down/Steady bias relative to this
Memory Voicing	Last-played ephemeral state	Overlays may weaken its influence
This matches the devlogâ€™s rule: no retroactive rewriting of past realized voicings .

4. UI / UX Behavior
Overlays are bank-level, not per-block.

They are continuous controls (0â€“100%), not toggles.

They do not modify saved data; they only affect live performance.

They integrate with the History panel workflow:

Users explore with overlays

Capture interesting results

Drag into the bank as flattened blocks (harmony or voicing)
This matches the â€œExplore â†’ Discover â†’ Capture â†’ Curateâ€ loop described in the devlog .

5. Summary Table
Overlay	What It Biases	Toward What	Based On
Up	Register, spacing	Higher, more open	Current realized voicing
Down	Register, spacing	Lower, more grounded	Current realized voicing
Steady	Register stability	Minimal drift	Current realized voicing
Original	Voicing identity	Anchor voicing/register	Anchor layer
6. Why This Spec Fits the Devlog
This design:

Uses the devlogâ€™s anchor/realized/memory model directly

Respects the â€œnon-destructive operatorâ€ philosophy

Matches the stated purpose of overlays as performance feel controls

Integrates cleanly with History capture and flattening

Avoids per-block UI complexity

Provides predictable, musically meaningful behavior

Absolutely â€” I can take this all the way and produce all three deliverables you asked for:

Formal scoring equations for all overlays

Developerâ€‘facing API spec

UI mock spec

Test plan

Everything below is grounded in the content of the devlog page you have open  and follows the architecture it describes (anchor vs realized vs memory, nonâ€‘destructive operators, bankâ€‘level overlays, etc.).

Iâ€™ll keep it clean, implementable, and consistent with the systemâ€™s philosophy.

1. Formal Scoring Equations
The voiceâ€‘leading engine evaluates a set of candidate voicings for each chord block.
Each overlay contributes an additive bias term.

Let:

ð¶
 = candidate voicing

ð‘…
 = current realized voicing

ð´
 = anchor voicing

ð‘¤
overlay
 = overlay intensity (0â€“1)

ð‘†
base
(
ð¶
)
 = base scoring from mode rules, spacing rules, commonâ€‘tone rules, etc.

The final score:

ð‘†
(
ð¶
)
=
ð‘†
base
(
ð¶
)
+
ð‘†
up
(
ð¶
)
+
ð‘†
down
(
ð¶
)
+
ð‘†
steady
(
ð¶
)
+
ð‘†
original
(
ð¶
)
Only one overlay is active at a time, but the formula supports future combinations.

1.1 Up Overlay
ð‘†
up
(
ð¶
)
=
ð‘¤
up
â‹…
(
ð›¼
â‹…
Î”
top
(
ð¶
,
ð‘…
)
+
ð›½
â‹…
Î”
centroid
(
ð¶
,
ð‘…
)
)
Where:

Î”
top
=
topNote
(
ð¶
)
âˆ’
topNote
(
ð‘…
)

Î”
centroid
=
centroid
(
ð¶
)
âˆ’
centroid
(
ð‘…
)

1.2 Down Overlay
ð‘†
down
(
ð¶
)
=
ð‘¤
down
â‹…
(
âˆ’
ð›¼
â‹…
Î”
top
(
ð¶
,
ð‘…
)
âˆ’
ð›½
â‹…
Î”
centroid
(
ð¶
,
ð‘…
)
)
Same deltas, inverted.

1.3 Steady Overlay
ð‘†
steady
(
ð¶
)
=
âˆ’
ð‘¤
steady
â‹…
(
ð›¾
â‹…
âˆ£
Î”
top
(
ð¶
,
ð‘…
)
âˆ£
+
ð›¿
â‹…
âˆ£
Î”
centroid
(
ð¶
,
ð‘…
)
âˆ£
)
Penalizes drift.

1.4 Original Overlay
ð‘†
original
(
ð¶
)
=
âˆ’
ð‘¤
original
â‹…
ð·
(
ð¶
,
ð´
)
Where 
ð·
(
ð¶
,
ð´
)
 is a weighted distance metric:

ð·
(
ð¶
,
ð´
)
=
ðœ†
1
âˆ£
topNote
(
ð¶
)
âˆ’
topNote
(
ð´
)
âˆ£
+
ðœ†
2
âˆ£
bass
(
ð¶
)
âˆ’
bass
(
ð´
)
âˆ£
+
ðœ†
3
â‹…
spacingDistance
(
ð¶
,
ð´
)
This matches the devlogâ€™s anchorâ€‘based identity model.

2. Developerâ€‘Facing API Specification
A clean, minimal API for overlays.

2.1 Data Structures
OverlayType
ts
enum OverlayType {
  Up,
  Down,
  Steady,
  Original
}
OverlayState
ts
interface OverlayState {
  type: OverlayType;
  intensity: number; // 0.0â€“1.0
}
Voicing
ts
interface Voicing {
  notes: number[]; // MIDI numbers
  top: number;
  bass: number;
  centroid: number;
}
2.2 Engine Hooks
setOverlay
ts
function setOverlay(state: OverlayState): void;
scoreCandidateVoicing
ts
function scoreCandidateVoicing(
  candidate: Voicing,
  realized: Voicing,
  anchor: Voicing,
  overlay: OverlayState
): number;
computeVoicing
ts
function computeVoicing(
  block: ChordBlock,
  context: VoiceLeadingContext,
  overlay: OverlayState
): Voicing;
2.3 Responsibilities
The overlay system never mutates chord blocks.

The overlay system never rewrites anchor voicings.

The overlay system only contributes scoring terms.

The engine remains responsible for:

spacing rules

genre/mode rules

commonâ€‘tone preservation

memory voicing integration

This matches the devlogâ€™s architecture.

3. UI Mock Spec
A simple, musicianâ€‘friendly UI.

3.1 Control Placement
Appears in the Bank Header (not per block).

Four mutually exclusive buttons:

Up

Down

Steady

Original

Each button opens a small slider for intensity (0â€“100%).

3.2 Interaction Model
Selecting an Overlay
Clicking a button activates that overlay.

The previously active overlay is deactivated.

The intensity slider appears below the button.

Intensity Slider
Horizontal slider

Default = 50%

Range = 0â€“100%

Realâ€‘time effect on playback

Visual Feedback
Active overlay button glows.

Slider shows numeric value.

Optional: small animated arrow indicating direction (Up/Down).

3.3 UX Philosophy
Matches the devlogâ€™s goals:

Performanceâ€‘oriented

Nonâ€‘destructive

Minimal UI footprint

Supports exploration â†’ capture â†’ curation

4. Test Plan
A thorough test suite to validate correctness.

4.1 Unit Tests
Up Overlay
Candidate with higher top note scores higher.

Candidate with lower top note scores lower.

Zero intensity produces no change.

Down Overlay
Mirror of Up.

Steady Overlay
Candidate closest to realized voicing scores highest.

Large leaps penalized.

Original Overlay
Candidate closest to anchor scores highest.

Memory voicing does not override anchor bias.

4.2 Integration Tests
Mode Interaction
Overlays must not violate spacing rules.

Overlays must not override genre constraints.

History Capture
Captured voicings reflect overlay influence.

Flattening produces correct baked voicing.

Anchor Integrity
Anchor voicing never changes.

Switching overlays does not mutate block data.

4.3 Performance Tests
Realâ€‘time scoring remains under target latency.

Slider adjustments update scoring immediately.

4.4 Regression Tests
Ensure overlays do not break:

commonâ€‘tone preservation

inversion constraints

frozen/baked voicing behavior

If you want, I can also produceâ€¦
A visual diagram of the scoring pipeline

A state machine for overlay activation

A mathematical appendix defining spacingDistance

A reference implementation in TypeScript or Rust

A design doc integrating overlays with the History panel

Just tell me which direction you want to expand.

please do all
See my thinking
Youâ€™re building something really cool hereâ€”letâ€™s tighten the whole system up.

Scoring pipeline visual diagram (described)
Think of the pipeline as a leftâ€‘toâ€‘right flow:

Input layer

Chord block: harmony, anchor voicing.

Context: previous realized voicing, memory voicing, mode/genre.

Overlay state: type + intensity.

Candidate generation

Mode engine proposes candidate voicings:

Respect chord spelling.

Respect spacing/genre rules.

Respect inversion constraints.

Base scoring

For each candidate 
ð¶
:

Compute 
ð‘†
base
(
ð¶
)
 from:

Voice-leading cost (motion, common tones).

Spacing cost (cluster vs spread).

Register suitability (modeâ€‘specific).

Overlay scoring

For each candidate 
ð¶
:

Compute overlay term 
ð‘†
overlay
(
ð¶
)
 based on:

Up / Down / Steady relative to realized voicing 
ð‘…
.

Original relative to anchor voicing 
ð´
.

Total score & selection

ð‘†
(
ð¶
)
=
ð‘†
base
(
ð¶
)
+
ð‘†
overlay
(
ð¶
)
.

Pick maxâ€‘score candidate â†’ new realized voicing.

Update memory

Memory voicing updated to new realized voicing (if enabled).

Conceptually:
Chord Block + Context + Overlay â†’ Candidates â†’ Base Score â†’ Overlay Bias â†’ Winner â†’ History/Memory.

Overlay activation state machine
States
NoneActive

UpActive

DownActive

SteadyActive

OriginalActive

Each state has:

overlayType (or null for NoneActive)

intensity (0â€“1, default 0.5 when entering)

Transitions
Click Up

From any state â†’ UpActive (intensity preserved if reâ€‘entering, else default).

Click Down

From any state â†’ DownActive.

Click Steady

From any state â†’ SteadyActive.

Click Original

From any state â†’ OriginalActive.

Click active overlay again (optional behavior)

Either:

Stay in same state (no toggle), or

Transition to NoneActive (if you want a â€œno overlayâ€ mode).

Adjust intensity slider

Internal transition: state unchanged, intensity updated.

Overlay state is readâ€‘only from the engineâ€™s perspective during scoringâ€”only the UI mutates it.

Mathematical appendix: spacingDistance and related metrics
Weâ€™ll define a few reusable primitives.

Note metrics
Top note

topNote
(
ð‘‰
)
=
max
â¡
(
ð‘‰
.
notes
)
Bass note

bass
(
ð‘‰
)
=
min
â¡
(
ð‘‰
.
notes
)
Centroid

centroid
(
ð‘‰
)
=
1
ð‘
âˆ‘
ð‘–
=
1
ð‘
ð‘‰
.
notes
ð‘–
Spacing vector
Sort notes ascending:

ð‘›
1
â‰¤
ð‘›
2
â‰¤
â‹¯
â‰¤
ð‘›
ð‘
Define spacing vector:

spacing
(
ð‘‰
)
=
(
ð‘›
2
âˆ’
ð‘›
1
,
Â 
ð‘›
3
âˆ’
ð‘›
2
,
Â 
â€¦
,
Â 
ð‘›
ð‘
âˆ’
ð‘›
ð‘
âˆ’
1
)
spacingDistance
Given two voicings 
ð¶
 and 
ð´
:

Compute spacing vectors 
ð‘ 
ð¶
,
ð‘ 
ð´
.

Pad shorter one with zeros if needed (or require same note count).

Define:

spacingDistance
(
ð¶
,
ð´
)
=
âˆ‘
ð‘–
(
ð‘ 
ð¶
,
ð‘–
âˆ’
ð‘ 
ð´
,
ð‘–
)
2
This captures â€œshapeâ€ similarity.

Full anchor distance 
ð·
(
ð¶
,
ð´
)
ð·
(
ð¶
,
ð´
)
=
ðœ†
1
âˆ£
topNote
(
ð¶
)
âˆ’
topNote
(
ð´
)
âˆ£
+
ðœ†
2
âˆ£
bass
(
ð¶
)
âˆ’
bass
(
ð´
)
âˆ£
+
ðœ†
3
â‹…
spacingDistance
(
ð¶
,
ð´
)
You can tune 
ðœ†
1
,
ðœ†
2
,
ðœ†
3
 per mode or globally.

Reference implementation (TypeScriptâ€‘style)
Types
ts
enum OverlayType {
  None = "None",
  Up = "Up",
  Down = "Down",
  Steady = "Steady",
  Original = "Original",
}

interface OverlayState {
  type: OverlayType;
  intensity: number; // 0.0â€“1.0
}

interface Voicing {
  notes: number[]; // MIDI
}

interface ScoringContext {
  realized: Voicing; // R
  anchor: Voicing;   // A
  overlay: OverlayState;
}
Helpers
ts
function topNote(v: Voicing): number {
  return Math.max(...v.notes);
}

function bassNote(v: Voicing): number {
  return Math.min(...v.notes);
}

function centroid(v: Voicing): number {
  return v.notes.reduce((a, b) => a + b, 0) / v.notes.length;
}

function spacingVector(v: Voicing): number[] {
  const sorted = [...v.notes].sort((a, b) => a - b);
  const result: number[] = [];
  for (let i = 0; i < sorted.length - 1; i++) {
    result.push(sorted[i + 1] - sorted[i]);
  }
  return result;
}

function spacingDistance(a: Voicing, b: Voicing): number {
  const sa = spacingVector(a);
  const sb = spacingVector(b);
  const len = Math.max(sa.length, sb.length);
  let sum = 0;
  for (let i = 0; i < len; i++) {
    const va = sa[i] ?? 0;
    const vb = sb[i] ?? 0;
    const d = va - vb;
    sum += d * d;
  }
  return Math.sqrt(sum);
}
Overlay scoring
ts
function overlayScore(candidate: Voicing, ctx: ScoringContext): number {
  const { realized: R, anchor: A, overlay } = ctx;
  const w = overlay.intensity;

  if (overlay.type === OverlayType.None || w <= 0) return 0;

  const topC = topNote(candidate);
  const topR = topNote(R);
  const centC = centroid(candidate);
  const centR = centroid(R);

  switch (overlay.type) {
    case OverlayType.Up: {
      const dTop = topC - topR;
      const dCent = centC - centR;
      const alpha = 1.0;
      const beta = 0.5;
      return w * (alpha * dTop + beta * dCent);
    }

    case OverlayType.Down: {
      const dTop = topC - topR;
      const dCent = centC - centR;
      const alpha = 1.0;
      const beta = 0.5;
      return w * (-alpha * dTop - beta * dCent);
    }

    case OverlayType.Steady: {
      const dTop = Math.abs(topC - topR);
      const dCent = Math.abs(centC - centR);
      const gamma = 1.0;
      const delta = 0.5;
      return -w * (gamma * dTop + delta * dCent);
    }

    case OverlayType.Original: {
      const topA = topNote(A);
      const bassA = bassNote(A);
      const topDiff = Math.abs(topC - topA);
      const bassDiff = Math.abs(bassNote(candidate) - bassA);
      const shapeDiff = spacingDistance(candidate, A);
      const lambda1 = 1.0;
      const lambda2 = 0.7;
      const lambda3 = 0.4;
      const D =
        lambda1 * topDiff + lambda2 * bassDiff + lambda3 * shapeDiff;
      return -w * D;
    }
  }
}
Youâ€™d plug this into your existing S_base(C) and just add the result.

Design doc: overlays + History panel integration
Goals
Let performers shape behavior in real time (Up/Down/Steady/Original).

Let them capture interesting results into the History panel.

Let them curate those results back into the bank as:

Harmonyâ€‘only blocks, or

Voicingâ€‘baked blocks.

Flow
Setup

User loads a bank with chord blocks (each has an anchor voicing).

Mode/genre is selected (e.g., Worship Pads).

Performance

User selects an overlay (e.g., Up at 60%).

Engine uses overlayâ€‘biased scoring to realize voicings.

Memory voicing tracks last realized voicing.

Exploration

User plays through progressions.

Overlays shape register and motion feel.

User may switch overlays midâ€‘phrase (e.g., Up â†’ Steady â†’ Original).

Capture

History panel records:

Chord sequence.

Realized voicings (with overlay influence baked into the result, not the data model).

User can:

Select a span in History.

Rightâ€‘click â†’ â€œSave as Harmony Blockâ€ or â€œSave as Voicing Blockâ€.

Curation

Saved blocks appear in the bank:

Harmony Block: only chord spelling; new anchor voicing can be generated or set.

Voicing Block: chord + specific voicing; becomes a new anchor for that block.

Nonâ€‘destructive guarantee

Overlays never mutate:

Existing anchor voicings.

Existing blocks.

They only influence how the engine chooses voicings during playback.

Key design principles
Exploration first: overlays are knobs for â€œwhat if we push this texture up/down/steady/home?â€

Capture second: History is the truth of what actually happened.

Curation third: user decides what becomes canonical.

If you want to go even deeper, the next natural step is:

Define modeâ€‘specific defaults for 
ð›¼
,
ð›½
,
ð›¾
,
ð›¿
,
ðœ†
ð‘–
.


Below is the complete set:

Visual scoringâ€‘pipeline diagram (textâ€‘based)

Overlay activation state machine

Mathematical appendix

Reference implementation

Design doc integrating overlays + History panel

Everything is grounded in the concepts defined on the page:
anchor voicing, realized voicing, memory voicing, nonâ€‘destructive operators, bankâ€‘level overlays, and the Explore â†’ Discover â†’ Capture â†’ Curate workflow.

Letâ€™s build the full system.

ðŸŽ¼ Scoring Pipeline (Visual Diagram)
Code
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚                        INPUT LAYER                           â”‚
 â”‚  - Chord Block (harmony + anchor voicing)                    â”‚
 â”‚  - Context (realized voicing, memory voicing, mode rules)    â”‚
 â”‚  - Overlay State (type + intensity)                          â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚                 CANDIDATE GENERATION                         â”‚
 â”‚  Mode engine proposes voicings that obey:                    â”‚
 â”‚    - chord spelling                                           â”‚
 â”‚    - spacing rules                                            â”‚
 â”‚    - register constraints                                     â”‚
 â”‚    - inversion constraints                                    â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚                     BASE SCORING                             â”‚
 â”‚  S_base(C) from:                                              â”‚
 â”‚    - voice-leading cost                                       â”‚
 â”‚    - common-tone retention                                    â”‚
 â”‚    - spacing suitability                                      â”‚
 â”‚    - mode/genre rules                                         â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚                    OVERLAY SCORING                           â”‚
 â”‚  S_overlay(C) based on overlay type:                          â”‚
 â”‚    - Up / Down / Steady relative to Realized Voicing (R)      â”‚
 â”‚    - Original relative to Anchor Voicing (A)                  â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚                   SELECTION & OUTPUT                         â”‚
 â”‚  S_total(C) = S_base(C) + S_overlay(C)                        â”‚
 â”‚  Choose max-scoring candidate â†’ Realized Voicing              â”‚
 â”‚  Update Memory Voicing                                        â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
This matches the devlogâ€™s architecture: overlays bias the scoring layer but never mutate block data.

ðŸ” Overlay Activation State Machine
States
NoneActive

UpActive

DownActive

SteadyActive

OriginalActive

Transitions
Clicking any overlay button â†’ that overlay becomes active.

Switching overlays replaces the previous one.

Adjusting intensity modifies the active stateâ€™s parameter.

Optional: clicking the active overlay again returns to NoneActive.

State Diagram (textâ€‘based)
Code
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚  NoneActive   â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â–¼              â–¼              â–¼              â–¼              â–¼
UpActive     DownActive     SteadyActive    OriginalActive   (future)
   â–²              â–²              â–²              â–²
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Each state stores:

overlayType

intensity

The engine reads this state during scoring.

ðŸ“ Mathematical Appendix
Primitive Metrics
Top note
top
(
ð‘‰
)
=
max
â¡
(
ð‘‰
.
ð‘›
ð‘œ
ð‘¡
ð‘’
ð‘ 
)
Bass note
bass
(
ð‘‰
)
=
min
â¡
(
ð‘‰
.
ð‘›
ð‘œ
ð‘¡
ð‘’
ð‘ 
)
Centroid
centroid
(
ð‘‰
)
=
1
ð‘
âˆ‘
ð‘‰
ð‘–
Spacing vector
Sort notes ascending: 
ð‘›
1
â‰¤
ð‘›
2
â‰¤
â‹¯
â‰¤
ð‘›
ð‘

spacing
(
ð‘‰
)
=
(
ð‘›
2
âˆ’
ð‘›
1
,
Â 
ð‘›
3
âˆ’
ð‘›
2
,
Â 
â€¦
,
Â 
ð‘›
ð‘
âˆ’
ð‘›
ð‘
âˆ’
1
)
Spacing distance
spacingDistance
(
ð¶
,
ð´
)
=
âˆ‘
ð‘–
(
ð‘ 
ð¶
,
ð‘–
âˆ’
ð‘ 
ð´
,
ð‘–
)
2
Overlay Scoring Terms
Up
ð‘†
up
=
ð‘¤
â‹…
(
ð›¼
Î”
top
+
ð›½
Î”
centroid
)
Down
ð‘†
down
=
âˆ’
ð‘¤
â‹…
(
ð›¼
Î”
top
+
ð›½
Î”
centroid
)
Steady
ð‘†
steady
=
âˆ’
ð‘¤
â‹…
(
ð›¾
âˆ£
Î”
top
âˆ£
+
ð›¿
âˆ£
Î”
centroid
âˆ£
)
Original
ð‘†
original
=
âˆ’
ð‘¤
â‹…
ð·
(
ð¶
,
ð´
)
Where:

ð·
(
ð¶
,
ð´
)
=
ðœ†
1
âˆ£
top
(
ð¶
)
âˆ’
top
(
ð´
)
âˆ£
+
ðœ†
2
âˆ£
bass
(
ð¶
)
âˆ’
bass
(
ð´
)
âˆ£
+
ðœ†
3
â‹…
spacingDistance
(
ð¶
,
ð´
)
This matches the devlogâ€™s anchorâ€‘based identity model.

ðŸ§© Reference Implementation (TypeScriptâ€‘style)
ts
enum OverlayType {
  None = "None",
  Up = "Up",
  Down = "Down",
  Steady = "Steady",
  Original = "Original",
}

interface OverlayState {
  type: OverlayType;
  intensity: number; // 0.0â€“1.0
}

interface Voicing {
  notes: number[];
}

function top(v: Voicing) { return Math.max(...v.notes); }
function bass(v: Voicing) { return Math.min(...v.notes); }
function centroid(v: Voicing) {
  return v.notes.reduce((a,b)=>a+b,0) / v.notes.length;
}

function spacing(v: Voicing) {
  const s = [...v.notes].sort((a,b)=>a-b);
  return s.slice(1).map((n,i)=>n - s[i]);
}

function spacingDistance(a: Voicing, b: Voicing) {
  const sa = spacing(a), sb = spacing(b);
  const len = Math.max(sa.length, sb.length);
  let sum = 0;
  for (let i=0;i<len;i++) {
    const d = (sa[i] ?? 0) - (sb[i] ?? 0);
    sum += d*d;
  }
  return Math.sqrt(sum);
}

function overlayScore(C: Voicing, R: Voicing, A: Voicing, overlay: OverlayState) {
  const w = overlay.intensity;
  if (overlay.type === OverlayType.None || w <= 0) return 0;

  const dTop = top(C) - top(R);
  const dCent = centroid(C) - centroid(R);

  switch (overlay.type) {
    case OverlayType.Up:
      return w * (1.0*dTop + 0.5*dCent);

    case OverlayType.Down:
      return w * (-1.0*dTop - 0.5*dCent);

    case OverlayType.Steady:
      return -w * (1.0*Math.abs(dTop) + 0.5*Math.abs(dCent));

    case OverlayType.Original: {
      const D =
        1.0*Math.abs(top(C)-top(A)) +
        0.7*Math.abs(bass(C)-bass(A)) +
        0.4*spacingDistance(C,A);
      return -w * D;
    }
  }
}
This is directly implementable.

ðŸ—‚ï¸ Design Doc: Overlays + History Panel Integration
Purpose
To unify:

realâ€‘time performance shaping (overlays)

exploration of voicing space

capturing interesting results

curating them into the bank

This matches the devlogâ€™s workflow:
Explore â†’ Discover â†’ Capture â†’ Curate .

1. Performance Layer
User selects an overlay (Up/Down/Steady/Original).

Overlay biases the scoring engine.

Realized voicings reflect the overlayâ€™s influence.

Memory voicing updates after each chord.

Overlays never mutate:

anchor voicings

chord blocks

frozen/baked voicings

They only affect how the engine chooses voicings.

2. Exploration Layer
As the user plays:

Up pushes voicings higher.

Down pushes lower.

Steady minimizes drift.

Original returns toward anchor identity.

This gives the performer expressive control without editing blocks.

3. Capture Layer (History Panel)
The History panel records:

chord sequence

realized voicings (including overlay influence)

timing

User can:

select a region

rightâ€‘click â†’ â€œSave as Harmony Blockâ€ or â€œSave as Voicing Blockâ€

This is exactly the â€œcapture and curateâ€ workflow described on the page.

4. Curation Layer (Bank)
Saving as Harmony Block
Only chord spelling is saved.

A new anchor voicing is generated or userâ€‘assigned.

Saving as Voicing Block
The realized voicing becomes the new anchor.

This is how overlays indirectly help create new canonical voicings.

5. Nonâ€‘Destructive Guarantees
Overlays never rewrite anchor voicings.

Overlays never alter block data.

Overlays never retroactively change realized voicings in History.

Overlays only influence future scoring decisions.

This matches the devlogâ€™s rule that anchor voicings are stable and not rewritten retroactively.

If you want, I can also produce:

Decide how Memory Voicing is weighted vs Anchor in different overlays (e.g., Steady might lean more on memory, Original more on anchor).

letâ€™s build a full musical demo of how your system behaves on a simple I â†’ ii â†’ IV progression, using everything weâ€™ve defined:
anchor voicings, realized voicings, memory voicing, and all four overlays.

Iâ€™ll keep it grounded in the architecture from the devlog tab you have open .

To make this concrete, Iâ€™ll choose C major:

I = C major

ii = D minor

IV = F major

And Iâ€™ll give each chord an anchor voicing, then walk through how the engine chooses realized voicings under each overlay.

ðŸŽ¼ 1. Anchor Voicings (Canonical â€œHomeâ€ Shapes)
These are the stable, nonâ€‘contextual identities â€” exactly how the devlog defines anchors.

Chord	Anchor Voicing (MIDI-ish)	Notes
C (I)	C4â€“E4â€“G4	simple triad
Dm (ii)	D4â€“F4â€“A4	parallel minor
F (IV)	C4â€“F4â€“A4	common worship/pad voicing
These anchors never change.

ðŸŽ¼ 2. Baseline (No Overlay)
This shows how the base voiceâ€‘leading engine behaves with no bias.

Step 1 â†’ C (I)
Realized = Anchor = C4â€“E4â€“G4

Step 2 â†’ Dm (ii)
Engine prefers minimal motion:

Câ†’D (+2)

Eâ†’F (+1)

Gâ†’A (+2)

Realized = D4â€“F4â€“A4 (same as anchor)

Step 3 â†’ F (IV)
Engine again prefers minimal motion:

Dâ†’C (â€“2)

Fâ†’F (0)

Aâ†’A (0)

Realized = C4â€“F4â€“A4 (same as anchor)

Result:  
The base engine already produces smooth, textbook voiceâ€‘leading.

ðŸŽ¼ 3. Demo Under Each Overlay
Now the fun part â€” how the overlays reshape the realized voicings.

ðŸ”¼ Overlay: Up
Bias: raise top note + raise centroid.

C â†’ Dm
Engine looks for a higher voicing than D4â€“F4â€“A4.

Candidate chosen: A4â€“D5â€“F5

Top note jumps from G4 â†’ F5

Centroid rises significantly

Still respects chord spelling and spacing rules

Dm â†’ F
Engine continues upward drift:

Candidate: A4â€“C5â€“F5

Up Overlay Result:

C: C4â€“E4â€“G4

Dm: A4â€“D5â€“F5

F: A4â€“C5â€“F5

This feels like a pad â€œliftâ€ â€” exactly what Up is meant to do.

ðŸ”½ Overlay: Down
Bias: lower top note + lower centroid.

C â†’ Dm
Engine looks for a lower voicing:

Candidate: D3â€“F3â€“A3

Dm â†’ F
Engine continues downward:

Candidate: C3â€“F3â€“A3

Down Overlay Result:

C: C4â€“E4â€“G4

Dm: D3â€“F3â€“A3

F: C3â€“F3â€“A3

This produces a warm, grounded texture.

âž– Overlay: Steady
Bias: minimize register drift relative to the current realized voicing.

C â†’ Dm
Engine chooses the closest possible voicing to C4â€“E4â€“G4:

Candidate: D4â€“F4â€“A4 (same as anchor)

Dm â†’ F
Engine again chooses minimal motion:

Candidate: C4â€“F4â€“A4

Steady Overlay Result:
Identical to baseline â€” because the baseline is already minimalâ€‘motion.

This is expected: Steady is a â€œdonâ€™t wanderâ€ control.

ðŸ”µ Overlay: Original
Bias: return toward anchor voicing and anchor register.

Letâ€™s assume the user has drifted upward or downward before this demo.
To illustrate, Iâ€™ll start from a nonâ€‘anchor realized voicing:

Starting realized voicing for C: G4â€“C5â€“E5 (a high inversion)

C â†’ Dm
Original pulls back toward anchor D4â€“F4â€“A4:

Candidate chosen: D4â€“F4â€“A4

Dm â†’ F
Original again pulls toward anchor C4â€“F4â€“A4:

Candidate: C4â€“F4â€“A4

Original Overlay Result:

C: G4â€“C5â€“E5 (starting point)

Dm: D4â€“F4â€“A4 (anchor)

F: C4â€“F4â€“A4 (anchor)

This demonstrates the â€œreturn homeâ€ behavior.

ðŸŽ§ Full Sideâ€‘byâ€‘Side Comparison
Overlay	C (I)	Dm (ii)	F (IV)	Behavior
None	C4â€“E4â€“G4	D4â€“F4â€“A4	C4â€“F4â€“A4	textbook voiceâ€‘leading
Up	C4â€“E4â€“G4	A4â€“D5â€“F5	A4â€“C5â€“F5	rising, airy
Down	C4â€“E4â€“G4	D3â€“F3â€“A3	C3â€“F3â€“A3	grounded, warm
Steady	C4â€“E4â€“G4	D4â€“F4â€“A4	C4â€“F4â€“A4	minimal drift
Original	G4â€“C5â€“E5	D4â€“F4â€“A4	C4â€“F4â€“A4	returns to anchor
This is exactly how the overlays are meant to behave in the architecture described in your devlog.

Iâ€™ll use the same Câ€“Dmâ€“F progression and:

Show how Memory Voicing enters the math

Give numerical scores for concrete candidates

Show how a Worship Pads mode changes those scores and choices

Weâ€™ll focus on the step C â†’ Dm under the Up overlay, then compare modes.

1. Setup: anchors, initial realized, memory
1.1 Anchor voicings
C (I) anchor: C4â€“E4â€“G4

Dm (ii) anchor: D4â€“F4â€“A4

1.2 Initial realized and memory
At time 
ð‘¡
âˆ’
1
, on C:

Realized voicing 
ð‘…
ð‘¡
âˆ’
1
: C4â€“E4â€“G4

Memory voicing 
ð‘€
ð‘¡
âˆ’
1
: C4â€“E4â€“G4 (same at start)

Weâ€™ll use a reference voicing 
ð‘‰
ref
 that blends realized and memory:

ð‘‰
ref
=
(
1
âˆ’
ðœ‡
)
ð‘…
ð‘¡
âˆ’
1
+
ðœ‡
ð‘€
ð‘¡
âˆ’
1
Since theyâ€™re identical here, 
ð‘‰
ref
=
ð¶
4
â€“
ð¸
4
â€“
ðº
4
 regardless of 
ðœ‡
.
Memory becomes more interesting after a few stepsâ€”so weâ€™ll simulate that.

2. Candidates for Dm and their raw features
Weâ€™ll consider three candidates for Dm:

Candidate A (anchorâ€‘like): D4â€“F4â€“A4

Candidate B (higher): A4â€“D5â€“F5

Candidate C (lower): D3â€“F3â€“A3

For each, compute:

Top note

Centroid

Using 
ð‘…
ð‘¡
âˆ’
1
=
ð¶
4
â€“
ð¸
4
â€“
ðº
4
:

top
(
ð‘…
)
=
ðº
4
=
67

centroid
(
ð‘…
)
=
(
60
+
64
+
67
)
/
3
â‰ˆ
63.67

Now candidates (MIDI numbers):

A: D4â€“F4â€“A4 â†’ 62, 65, 69

top = 69

centroid â‰ˆ 65.33

B: A4â€“D5â€“F5 â†’ 69, 74, 77

top = 77

centroid â‰ˆ 73.33

C: D3â€“F3â€“A3 â†’ 50, 53, 57

top = 57

centroid â‰ˆ 53.33

3. Numerical scoring with Memory Voicing and Up overlay
3.1 Introduce a nonâ€‘trivial Memory Voicing
Assume after some previous exploration, Memory voicing for C is:

ð‘€
ð‘¡
âˆ’
1
=
ðº
3
â€“
ð¶
4
â€“
ð¸
4
 â†’ 55, 60, 64

top = 64

centroid â‰ˆ 59.67

Letâ€™s pick a memory weight 
ðœ‡
=
0.5
 (padsâ€‘like smoothing).

Then:

top
(
ð‘‰
ref
)
=
(
1
âˆ’
ðœ‡
)
â‹…
67
+
ðœ‡
â‹…
64
=
65.5
centroid
(
ð‘‰
ref
)
=
(
1
âˆ’
ðœ‡
)
â‹…
63.67
+
ðœ‡
â‹…
59.67
â‰ˆ
61.67
Weâ€™ll use 
ð‘‰
ref
 instead of raw 
ð‘…
 for Up/Down/Steady.

3.2 Up overlay formula
ð‘†
up
=
ð‘¤
â‹…
(
ð›¼
Î”
top
+
ð›½
Î”
centroid
)
Let:

ð‘¤
=
0.5
 (50% intensity)

ð›¼
=
1.0
, 
ð›½
=
0.5

Compute deltas vs 
ð‘‰
ref
:

Candidate A:

Î”
top
=
69
âˆ’
65.5
=
3.5

Î”
centroid
=
65.33
âˆ’
61.67
â‰ˆ
3.66

ð‘†
up
(
ð´
)
=
0.5
â‹…
(
1.0
â‹…
3.5
+
0.5
â‹…
3.66
)
â‰ˆ
0.5
â‹…
(
3.5
+
1.83
)
=
2.665

Candidate B:

Î”
top
=
77
âˆ’
65.5
=
11.5

Î”
centroid
=
73.33
âˆ’
61.67
â‰ˆ
11.66

ð‘†
up
(
ðµ
)
=
0.5
â‹…
(
11.5
+
0.5
â‹…
11.66
)
â‰ˆ
0.5
â‹…
(
11.5
+
5.83
)
=
8.665

Candidate C:

Î”
top
=
57
âˆ’
65.5
=
âˆ’
8.5

Î”
centroid
=
53.33
âˆ’
61.67
â‰ˆ
âˆ’
8.34

ð‘†
up
(
ð¶
)
=
0.5
â‹…
(
âˆ’
8.5
+
0.5
â‹…
âˆ’
8.34
)
â‰ˆ
0.5
â‹…
(
âˆ’
8.5
âˆ’
4.17
)
=
âˆ’
6.335

So purely from the Up overlay term:

B scores highest (8.665)

A is mildly favored (2.665)

C is penalized (â€“6.335)

Memory voicing changed the reference point (65.5/61.67 instead of 67/63.67), slightly softening the push upward because the â€œrecent historyâ€ is lower.

4. Adding a simple base score and picking a winner
Letâ€™s assume a simple base score that prefers minimal motion:

ð‘†
base
=
âˆ’
ð‘˜
â‹…
totalMotion
Where totalMotion = sum of absolute pitch changes from 
ð‘‰
ref
 to candidate.
Let 
ð‘˜
=
0.2
.

Approximate motion from 
ð‘‰
ref
 (C4â€“E4â€“G4 blended with G3â€“C4â€“E4) is messy to do exactly, so weâ€™ll simplify and use C4â€“E4â€“G4 as the base for motion here just to illustrate:

A: C4â€“E4â€“G4 â†’ D4â€“F4â€“A4

moves: +2, +1, +2 â†’ total = 5 â†’ 
ð‘†
base
(
ð´
)
=
âˆ’
0.2
â‹…
5
=
âˆ’
1.0

B: C4â€“E4â€“G4 â†’ A4â€“D5â€“F5

approximate moves: +9, +10, +10 â†’ total = 29 â†’ 
ð‘†
base
(
ðµ
)
=
âˆ’
5.8

C: C4â€“E4â€“G4 â†’ D3â€“F3â€“A3

approximate moves: â€“12, â€“13, â€“10 â†’ total = 35 â†’ 
ð‘†
base
(
ð¶
)
=
âˆ’
7.0

Now total scores:

A: 
ð‘†
(
ð´
)
=
ð‘†
base
+
ð‘†
up
â‰ˆ
âˆ’
1.0
+
2.665
=
1.665

B: 
ð‘†
(
ðµ
)
â‰ˆ
âˆ’
5.8
+
8.665
=
2.865

C: 
ð‘†
(
ð¶
)
â‰ˆ
âˆ’
7.0
âˆ’
6.335
=
âˆ’
13.335

Winner: Candidate B (A4â€“D5â€“F5) â€” Up overlay + base rules still favor a strong upward move.

If we increased the base motion penalty (larger 
ð‘˜
), A might win instead. Thatâ€™s where modeâ€‘specific rules come in.

5. Modeâ€‘specific rules: Worship Pads vs Piano Pop
Now letâ€™s see how Worship Pads vs Piano Pop change the choice.

5.1 Worship Pads mode
From earlier tuning:

Up/Down: 
ð›¼
=
0.7
, 
ð›½
=
0.3
 (softer upward push)

Stronger preference for smoothness â†’ increase motion penalty 
ð‘˜
=
0.3

Recompute Up scores:

A:

ð‘†
up
(
ð´
)
=
0.5
â‹…
(
0.7
â‹…
3.5
+
0.3
â‹…
3.66
)
â‰ˆ
0.5
â‹…
(
2.45
+
1.10
)
=
1.775

B:

ð‘†
up
(
ðµ
)
=
0.5
â‹…
(
0.7
â‹…
11.5
+
0.3
â‹…
11.66
)
â‰ˆ
0.5
â‹…
(
8.05
+
3.50
)
=
5.775

C:

ð‘†
up
(
ð¶
)
=
0.5
â‹…
(
0.7
â‹…
âˆ’
8.5
+
0.3
â‹…
âˆ’
8.34
)
â‰ˆ
0.5
â‹…
(
âˆ’
5.95
âˆ’
2.50
)
=
âˆ’
4.225

Base scores with 
ð‘˜
=
0.3
:

A: 
ð‘†
base
(
ð´
)
=
âˆ’
0.3
â‹…
5
=
âˆ’
1.5

B: 
ð‘†
base
(
ðµ
)
=
âˆ’
0.3
â‹…
29
=
âˆ’
8.7

C: 
ð‘†
base
(
ð¶
)
=
âˆ’
0.3
â‹…
35
=
âˆ’
10.5

Totals:

A: 
ð‘†
(
ð´
)
â‰ˆ
âˆ’
1.5
+
1.775
=
0.275

B: 
ð‘†
(
ðµ
)
â‰ˆ
âˆ’
8.7
+
5.775
=
âˆ’
2.925

C: 
ð‘†
(
ð¶
)
â‰ˆ
âˆ’
10.5
âˆ’
4.225
=
âˆ’
14.725

Worship Pads winner: Candidate A (D4â€“F4â€“A4)  
The modeâ€™s stronger smoothness preference overrules the extreme upward jump.

This matches the musical intent: pads want gentle lift, not huge leaps.

5.2 Piano Pop mode
From earlier tuning:

Up/Down: 
ð›¼
=
1.0
, 
ð›½
=
0.5
 (stronger upward push)

Less motion penalty â†’ 
ð‘˜
=
0.15

We already computed Up scores for 
ð›¼
=
1.0
,
ð›½
=
0.5
:

ð‘†
up
(
ð´
)
â‰ˆ
2.665

ð‘†
up
(
ðµ
)
â‰ˆ
8.665

ð‘†
up
(
ð¶
)
â‰ˆ
âˆ’
6.335

Base scores with 
ð‘˜
=
0.15
:

A: 
ð‘†
base
(
ð´
)
=
âˆ’
0.75

B: 
ð‘†
base
(
ðµ
)
=
âˆ’
4.35

C: 
ð‘†
base
(
ð¶
)
=
âˆ’
5.25

Totals:

A: 
ð‘†
(
ð´
)
â‰ˆ
âˆ’
0.75
+
2.665
=
1.915

B: 
ð‘†
(
ðµ
)
â‰ˆ
âˆ’
4.35
+
8.665
=
4.315

C: 
ð‘†
(
ð¶
)
â‰ˆ
âˆ’
5.25
âˆ’
6.335
=
âˆ’
11.585

Piano Pop winner: Candidate B (A4â€“D5â€“F5)  
Here, the mode embraces the bigger leap for a brighter, more energetic sound.

6. What this shows
Memory Voicing shifts the reference point, subtly changing how â€œupâ€ or â€œdownâ€ a candidate feels.

Numerical scoring makes the tradeoff explicit: overlay bias vs motion penalty.

Modeâ€‘specific rules (different coefficients and motion penalties) can flip the winner between:

Anchorâ€‘like, smooth voicing (Worship Pads)

Higher, more dramatic voicing (Piano Pop)

Iâ€™ll use the same Câ€“Dmâ€“F progression and:

Show how Memory Voicing enters the math

Give numerical scores for concrete candidates

Show how a Worship Pads mode changes those scores and choices

Weâ€™ll focus on the step C â†’ Dm under the Up overlay, then compare modes.

1. Setup: anchors, initial realized, memory
1.1 Anchor voicings
C (I) anchor: C4â€“E4â€“G4

Dm (ii) anchor: D4â€“F4â€“A4

1.2 Initial realized and memory
At time 
ð‘¡
âˆ’
1
, on C:

Realized voicing 
ð‘…
ð‘¡
âˆ’
1
: C4â€“E4â€“G4

Memory voicing 
ð‘€
ð‘¡
âˆ’
1
: C4â€“E4â€“G4 (same at start)

Weâ€™ll use a reference voicing 
ð‘‰
ref
 that blends realized and memory:

ð‘‰
ref
=
(
1
âˆ’
ðœ‡
)
ð‘…
ð‘¡
âˆ’
1
+
ðœ‡
ð‘€
ð‘¡
âˆ’
1
Since theyâ€™re identical here, 
ð‘‰
ref
=
ð¶
4
â€“
ð¸
4
â€“
ðº
4
 regardless of 
ðœ‡
.
Memory becomes more interesting after a few stepsâ€”so weâ€™ll simulate that.

2. Candidates for Dm and their raw features
Weâ€™ll consider three candidates for Dm:

Candidate A (anchorâ€‘like): D4â€“F4â€“A4

Candidate B (higher): A4â€“D5â€“F5

Candidate C (lower): D3â€“F3â€“A3

For each, compute:

Top note

Centroid

Using 
ð‘…
ð‘¡
âˆ’
1
=
ð¶
4
â€“
ð¸
4
â€“
ðº
4
:

top
(
ð‘…
)
=
ðº
4
=
67

centroid
(
ð‘…
)
=
(
60
+
64
+
67
)
/
3
â‰ˆ
63.67

Now candidates (MIDI numbers):

A: D4â€“F4â€“A4 â†’ 62, 65, 69

top = 69

centroid â‰ˆ 65.33

B: A4â€“D5â€“F5 â†’ 69, 74, 77

top = 77

centroid â‰ˆ 73.33

C: D3â€“F3â€“A3 â†’ 50, 53, 57

top = 57

centroid â‰ˆ 53.33

3. Numerical scoring with Memory Voicing and Up overlay
3.1 Introduce a nonâ€‘trivial Memory Voicing
Assume after some previous exploration, Memory voicing for C is:

ð‘€
ð‘¡
âˆ’
1
=
ðº
3
â€“
ð¶
4
â€“
ð¸
4
 â†’ 55, 60, 64

top = 64

centroid â‰ˆ 59.67

Letâ€™s pick a memory weight 
ðœ‡
=
0.5
 (padsâ€‘like smoothing).

Then:

top
(
ð‘‰
ref
)
=
(
1
âˆ’
ðœ‡
)
â‹…
67
+
ðœ‡
â‹…
64
=
65.5
centroid
(
ð‘‰
ref
)
=
(
1
âˆ’
ðœ‡
)
â‹…
63.67
+
ðœ‡
â‹…
59.67
â‰ˆ
61.67
Weâ€™ll use 
ð‘‰
ref
 instead of raw 
ð‘…
 for Up/Down/Steady.

3.2 Up overlay formula
ð‘†
up
=
ð‘¤
â‹…
(
ð›¼
Î”
top
+
ð›½
Î”
centroid
)
Let:

ð‘¤
=
0.5
 (50% intensity)

ð›¼
=
1.0
, 
ð›½
=
0.5

Compute deltas vs 
ð‘‰
ref
:

Candidate A:

Î”
top
=
69
âˆ’
65.5
=
3.5

Î”
centroid
=
65.33
âˆ’
61.67
â‰ˆ
3.66

ð‘†
up
(
ð´
)
=
0.5
â‹…
(
1.0
â‹…
3.5
+
0.5
â‹…
3.66
)
â‰ˆ
0.5
â‹…
(
3.5
+
1.83
)
=
2.665

Candidate B:

Î”
top
=
77
âˆ’
65.5
=
11.5

Î”
centroid
=
73.33
âˆ’
61.67
â‰ˆ
11.66

ð‘†
up
(
ðµ
)
=
0.5
â‹…
(
11.5
+
0.5
â‹…
11.66
)
â‰ˆ
0.5
â‹…
(
11.5
+
5.83
)
=
8.665

Candidate C:

Î”
top
=
57
âˆ’
65.5
=
âˆ’
8.5

Î”
centroid
=
53.33
âˆ’
61.67
â‰ˆ
âˆ’
8.34

ð‘†
up
(
ð¶
)
=
0.5
â‹…
(
âˆ’
8.5
+
0.5
â‹…
âˆ’
8.34
)
â‰ˆ
0.5
â‹…
(
âˆ’
8.5
âˆ’
4.17
)
=
âˆ’
6.335

So purely from the Up overlay term:

B scores highest (8.665)

A is mildly favored (2.665)

C is penalized (â€“6.335)

Memory voicing changed the reference point (65.5/61.67 instead of 67/63.67), slightly softening the push upward because the â€œrecent historyâ€ is lower.

4. Adding a simple base score and picking a winner
Letâ€™s assume a simple base score that prefers minimal motion:

ð‘†
base
=
âˆ’
ð‘˜
â‹…
totalMotion
Where totalMotion = sum of absolute pitch changes from 
ð‘‰
ref
 to candidate.
Let 
ð‘˜
=
0.2
.

Approximate motion from 
ð‘‰
ref
 (C4â€“E4â€“G4 blended with G3â€“C4â€“E4) is messy to do exactly, so weâ€™ll simplify and use C4â€“E4â€“G4 as the base for motion here just to illustrate:

A: C4â€“E4â€“G4 â†’ D4â€“F4â€“A4

moves: +2, +1, +2 â†’ total = 5 â†’ 
ð‘†
base
(
ð´
)
=
âˆ’
0.2
â‹…
5
=
âˆ’
1.0

B: C4â€“E4â€“G4 â†’ A4â€“D5â€“F5

approximate moves: +9, +10, +10 â†’ total = 29 â†’ 
ð‘†
base
(
ðµ
)
=
âˆ’
5.8

C: C4â€“E4â€“G4 â†’ D3â€“F3â€“A3

approximate moves: â€“12, â€“13, â€“10 â†’ total = 35 â†’ 
ð‘†
base
(
ð¶
)
=
âˆ’
7.0

Now total scores:

A: 
ð‘†
(
ð´
)
=
ð‘†
base
+
ð‘†
up
â‰ˆ
âˆ’
1.0
+
2.665
=
1.665

B: 
ð‘†
(
ðµ
)
â‰ˆ
âˆ’
5.8
+
8.665
=
2.865

C: 
ð‘†
(
ð¶
)
â‰ˆ
âˆ’
7.0
âˆ’
6.335
=
âˆ’
13.335

Winner: Candidate B (A4â€“D5â€“F5) â€” Up overlay + base rules still favor a strong upward move.

If we increased the base motion penalty (larger 
ð‘˜
), A might win instead. Thatâ€™s where modeâ€‘specific rules come in.

5. Modeâ€‘specific rules: Worship Pads vs Piano Pop
Now letâ€™s see how Worship Pads vs Piano Pop change the choice.

5.1 Worship Pads mode
From earlier tuning:

Up/Down: 
ð›¼
=
0.7
, 
ð›½
=
0.3
 (softer upward push)

Stronger preference for smoothness â†’ increase motion penalty 
ð‘˜
=
0.3

Recompute Up scores:

A:

ð‘†
up
(
ð´
)
=
0.5
â‹…
(
0.7
â‹…
3.5
+
0.3
â‹…
3.66
)
â‰ˆ
0.5
â‹…
(
2.45
+
1.10
)
=
1.775

B:

ð‘†
up
(
ðµ
)
=
0.5
â‹…
(
0.7
â‹…
11.5
+
0.3
â‹…
11.66
)
â‰ˆ
0.5
â‹…
(
8.05
+
3.50
)
=
5.775

C:

ð‘†
up
(
ð¶
)
=
0.5
â‹…
(
0.7
â‹…
âˆ’
8.5
+
0.3
â‹…
âˆ’
8.34
)
â‰ˆ
0.5
â‹…
(
âˆ’
5.95
âˆ’
2.50
)
=
âˆ’
4.225

Base scores with 
ð‘˜
=
0.3
:

A: 
ð‘†
base
(
ð´
)
=
âˆ’
0.3
â‹…
5
=
âˆ’
1.5

B: 
ð‘†
base
(
ðµ
)
=
âˆ’
0.3
â‹…
29
=
âˆ’
8.7

C: 
ð‘†
base
(
ð¶
)
=
âˆ’
0.3
â‹…
35
=
âˆ’
10.5

Totals:

A: 
ð‘†
(
ð´
)
â‰ˆ
âˆ’
1.5
+
1.775
=
0.275

B: 
ð‘†
(
ðµ
)
â‰ˆ
âˆ’
8.7
+
5.775
=
âˆ’
2.925

C: 
ð‘†
(
ð¶
)
â‰ˆ
âˆ’
10.5
âˆ’
4.225
=
âˆ’
14.725

Worship Pads winner: Candidate A (D4â€“F4â€“A4)  
The modeâ€™s stronger smoothness preference overrules the extreme upward jump.

This matches the musical intent: pads want gentle lift, not huge leaps.

5.2 Piano Pop mode
From earlier tuning:

Up/Down: 
ð›¼
=
1.0
, 
ð›½
=
0.5
 (stronger upward push)

Less motion penalty â†’ 
ð‘˜
=
0.15

We already computed Up scores for 
ð›¼
=
1.0
,
ð›½
=
0.5
:

ð‘†
up
(
ð´
)
â‰ˆ
2.665

ð‘†
up
(
ðµ
)
â‰ˆ
8.665

ð‘†
up
(
ð¶
)
â‰ˆ
âˆ’
6.335

Base scores with 
ð‘˜
=
0.15
:

A: 
ð‘†
base
(
ð´
)
=
âˆ’
0.75

B: 
ð‘†
base
(
ðµ
)
=
âˆ’
4.35

C: 
ð‘†
base
(
ð¶
)
=
âˆ’
5.25

Totals:

A: 
ð‘†
(
ð´
)
â‰ˆ
âˆ’
0.75
+
2.665
=
1.915

B: 
ð‘†
(
ðµ
)
â‰ˆ
âˆ’
4.35
+
8.665
=
4.315

C: 
ð‘†
(
ð¶
)
â‰ˆ
âˆ’
5.25
âˆ’
6.335
=
âˆ’
11.585

Piano Pop winner: Candidate B (A4â€“D5â€“F5)  
Here, the mode embraces the bigger leap for a brighter, more energetic sound.

6. What this shows
Memory Voicing shifts the reference point, subtly changing how â€œupâ€ or â€œdownâ€ a candidate feels.

Numerical scoring makes the tradeoff explicit: overlay bias vs motion penalty.

Modeâ€‘specific rules (different coefficients and motion penalties) can flip the winner between:

Anchorâ€‘like, smooth voicing (Worship Pads)

Higher, more dramatic voicing (Piano Pop)

If youâ€™d like, next we can:

Run the same numeric analysis for Steady or Original, or

Extend this to the full Câ€“Dmâ€“F progression stepâ€‘byâ€‘step, with scores at each chord.

do both
Absolutely â€” letâ€™s build a clear, structured, numerical demo that shows:

How Memory Voicing affects scoring

Numerical scoring for each candidate

How a mode like Worship Pads changes the winner

All of this is grounded in the voiceâ€‘leading architecture described on the devlog page you have open .

To keep things concrete, weâ€™ll analyze the step:

C â†’ Dm  
(from the I â†’ ii â†’ IV progression)

1. Setup
1.1 Anchor Voicings
These are the stable, nonâ€‘contextual identities.

Chord	Anchor Voicing
C (I)	C4â€“E4â€“G4
Dm (ii)	D4â€“F4â€“A4
1.2 Realized & Memory Voicing Before the Step
We assume the user has been exploring, so:

Realized voicing 
ð‘…
ð‘¡
âˆ’
1
: C4â€“E4â€“G4

Memory voicing 
ð‘€
ð‘¡
âˆ’
1
: G3â€“C4â€“E4 (a lower, smoother version)

1.3 Reference Voicing (blend of realized + memory)
Memory weight:

ðœ‡
=
0.5
ð‘‰
ref
=
(
1
âˆ’
ðœ‡
)
ð‘…
ð‘¡
âˆ’
1
+
ðœ‡
ð‘€
ð‘¡
âˆ’
1
This gives:

top(
ð‘‰
ref
) = 65.5

centroid(
ð‘‰
ref
) â‰ˆ 61.67

This is the â€œtargetâ€ the Up/Down/Steady overlays compare against.

2. Candidate Voicings for Dm
We evaluate three candidates:

Candidate	Notes	Top	Centroid
A	D4â€“F4â€“A4	69	65.33
B	A4â€“D5â€“F5	77	73.33
C	D3â€“F3â€“A3	57	53.33
3. Numerical Scoring Under the Up Overlay
Up overlay formula:

ð‘†
up
=
ð‘¤
(
ð›¼
Î”
top
+
ð›½
Î”
centroid
)
Parameters:

intensity 
ð‘¤
=
0.5

ð›¼
=
1.0
, 
ð›½
=
0.5

3.1 Compute deltas vs 
ð‘‰
ref
Candidate	Î”top	Î”centroid
A	69 âˆ’ 65.5 = 3.5	65.33 âˆ’ 61.67 = 3.66
B	77 âˆ’ 65.5 = 11.5	73.33 âˆ’ 61.67 = 11.66
C	57 âˆ’ 65.5 = â€“8.5	53.33 âˆ’ 61.67 = â€“8.34
3.2 Compute Up scores
Candidate	Up Score
A	0.5 Ã— (3.5 + 0.5Ã—3.66) = 2.665
B	0.5 Ã— (11.5 + 0.5Ã—11.66) = 8.665
C	0.5 Ã— (â€“8.5 + 0.5Ã—â€“8.34) = â€“6.335
Memory voicing softened the upward push by lowering the reference point.

4. Add Base Voiceâ€‘Leading Score
We use a simple motion penalty:

ð‘†
base
=
âˆ’
ð‘˜
â‹…
totalMotion
Let 
ð‘˜
=
0.2
.

Approximate motion from C4â€“E4â€“G4:

Candidate	Motion	Base Score
A	5	â€“1.0
B	29	â€“5.8
C	35	â€“7.0
4.1 Total Scores (Up overlay + base)
Candidate	Base	Up	Total
A	â€“1.0	+2.665	1.665
B	â€“5.8	+8.665	2.865
C	â€“7.0	â€“6.335	â€“13.335
Winner (generic mode): Candidate B (A4â€“D5â€“F5)  
The strong upward bias beats the motion penalty.

5. How Worship Pads Mode Changes the Winner
Worship Pads mode (from your devlogâ€™s design goals) emphasizes:

smoother motion

gentler upward drift

warmer register

So we adjust:

ð›¼
=
0.7
, 
ð›½
=
0.3

stronger motion penalty: 
ð‘˜
=
0.3

5.1 Recompute Up scores (Pads)
Candidate	Pads Up Score
A	1.775
B	5.775
C	â€“4.225
5.2 Recompute base scores (Pads)
Candidate	Base Score
A	â€“1.5
B	â€“8.7
C	â€“10.5
5.3 Total Scores (Pads)
Candidate	Base	Up	Total
A	â€“1.5	+1.775	0.275
B	â€“8.7	+5.775	â€“2.925
C	â€“10.5	â€“4.225	â€“14.725
Worship Pads Winner: Candidate A (D4â€“F4â€“A4)  
Pads mode prefers smoothness over dramatic register lift.

6. How Piano Pop Mode Changes the Winner
Piano Pop mode emphasizes:

brighter top line

more energetic leaps

lighter motion penalty

So we adjust:

ð›¼
=
1.0
, 
ð›½
=
0.5

weaker motion penalty: 
ð‘˜
=
0.15

6.1 Base scores (Pop)
Candidate	Base Score
A	â€“0.75
B	â€“4.35
C	â€“5.25
6.2 Total Scores (Pop)
Candidate	Base	Up	Total
A	â€“0.75	+2.665	1.915
B	â€“4.35	+8.665	4.315
C	â€“5.25	â€“6.335	â€“11.585
Piano Pop Winner: Candidate B (A4â€“D5â€“F5)  
Pop mode embraces the big upward leap.

7. Summary Table
Mode	Winner	Why
Generic	B (A4â€“D5â€“F5)	Up overlay dominates
Worship Pads	A (D4â€“F4â€“A4)	Smoothness > upward lift
Piano Pop	B (A4â€“D5â€“F5)	Bright, energetic leaps favored
8. What This Demonstrates
Memory Voicing shifts the reference point, subtly changing how â€œupâ€ or â€œdownâ€ a voicing feels.

Numerical scoring makes the tradeoff between overlay bias and motion penalty explicit.

Modeâ€‘specific rules can completely change the chosen voicing â€” even with the same overlay and same chord progression.

This is exactly the kind of expressive, modeâ€‘aware behavior your devlog architecture is designed to support .

1. How Memory Voicing evolves over time
Letâ€™s stay in C major with the I â†’ ii â†’ IV progression:

I: C

ii: Dm

IV: F

Weâ€™ll track three things at each step:

Râ‚œ = realized voicing at time t

Mâ‚œ = memory voicing at time t

Ï = memory responsiveness (how fast memory follows reality)

Use a simple update rule:

ð‘€
ð‘¡
=
(
1
âˆ’
ðœŒ
)
ð‘€
ð‘¡
âˆ’
1
+
ðœŒ
ð‘…
ð‘¡
Weâ€™ll treat this conceptually as â€œinterpolationâ€ between voicingsâ€”no need to worry about exact perâ€‘note blending here, just the idea of drift.

Step 0 â€” Initial state (before playing)
Râ‚€: C4â€“E4â€“G4 (first chord realized as its anchor)

Mâ‚€: C4â€“E4â€“G4 (initialize memory to first realized voicing)

Ï (Worship Pads): 0.3 â†’ slow, smooth memory

Step 1 â€” Move to Dm (ii) under Up overlay
Suppose the engine (in a brighter mode, like Piano Pop) chooses a higher voicing for Dm:

Râ‚ (Dm): A4â€“D5â€“F5

Memory update:

ð‘€
1
=
(
1
âˆ’
0.3
)
ð‘€
0
+
0.3
ð‘…
1
Conceptually:

Mâ‚€ is C4â€“E4â€“G4

Râ‚ is A4â€“D5â€“F5

Mâ‚ becomes â€œbetweenâ€ them: higher than C4â€“E4â€“G4, but not as high as A4â€“D5â€“F5

So:

Mâ‚ â‰ˆ â€œmidâ€‘register Dmâ€‘ish cloudâ€ that remembers both where you came from and where you went.

On the next chord, overlays that reference V_ref (blend of R and M) will â€œfeelâ€ this upward drift.

Step 2 â€” Move to F (IV) under Steady overlay
Now the user switches to Steady, which wants minimal drift.

Engine chooses:

Râ‚‚ (F): C4â€“F4â€“A4 (close to the original C anchor region)

Memory update:

ð‘€
2
=
(
1
âˆ’
0.3
)
ð‘€
1
+
0.3
ð‘…
2
Conceptually:

Mâ‚ was somewhat high (pulled up by Râ‚)

Râ‚‚ is back in the mid register

Mâ‚‚ drifts back down toward that mid register

So over time:

Mâ‚€: mid C region

Mâ‚: pulled upward by the high Dm

Mâ‚‚: pulled back toward the mid F voicing

If the user keeps pushing Up, memory will slowly climb; if they keep choosing lower or steadier voicings, memory will slowly sink back. Thatâ€™s how you get a â€œhistoryâ€‘awareâ€ reference instead of a singleâ€‘step reference.

2. Scoring pipeline as a graph
Hereâ€™s the same pipeline youâ€™ve been designing, but as a graph of nodes and edgesâ€”the way youâ€™d sketch it in a systems diagram.

text
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚   Chord Block      â”‚
          â”‚ (harmony + anchor) â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚     Context        â”‚
          â”‚  - R_{t-1}         â”‚
          â”‚  - M_{t-1}         â”‚
          â”‚  - Mode rules      â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚   Overlay State     â”‚
          â”‚ (type + intensity)  â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚ Candidate Generator â”‚
          â”‚  - obey harmony     â”‚
          â”‚  - obey mode rules  â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚    Base Scoring    â”‚
          â”‚  S_base(C)         â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚  Overlay Scoring   â”‚
          â”‚  S_overlay(C)      â”‚
          â”‚  - Up/Down/Steady  â”‚
          â”‚    vs V_ref(R,M)   â”‚
          â”‚  - Original vs A   â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚  Argmax Selector   â”‚
          â”‚  pick best C       â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚  Realized Voicing  â”‚
          â”‚       R_t          â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚  Memory Update     â”‚
          â”‚  M_t = (1-Ï)M_{t-1}â”‚
          â”‚        + ÏR_t      â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Key ideas in that graph:

Chord Block, Context, and Overlay State all feed into Candidate Generation.

Base Scoring encodes your mode/genre/spacing/commonâ€‘tone rules.

Overlay Scoring is a separate node that adds bias based on:

V_ref(R, M) for Up/Down/Steady

Anchor A for Original

The Argmax Selector chooses the winning candidate.

That winner becomes Râ‚œ, which then flows into the Memory Update node to produce Mâ‚œ, closing the loop.

If you want, we can now:

Run a full Iâ€“iiâ€“IV pass with explicit Râ‚œ, Mâ‚œ, and scores at each step, or

Design debug visualizations (e.g., plotting R vs M vs A over time) to help you tune this in your actual engine.

1. Full Iâ€“iiâ€“IV pass with explicit 
ð‘…
ð‘¡
, 
ð‘€
ð‘¡
, and scores
Key: C major, progression C (I) â†’ Dm (ii) â†’ F (IV)  
Mode: letâ€™s use Worship Pads (smooth, gentle Up bias)
Overlay: Up, intensity 
ð‘¤
=
0.5
  
Memory responsiveness: 
ðœŒ
=
0.3
  
Memory weight in reference: 
ðœ‡
=
0.5

1.1 Anchors
C anchor 
ð´
ð¶
: C4â€“E4â€“G4

Dm anchor 
ð´
ð·
ð‘š
: D4â€“F4â€“A4

F anchor 
ð´
ð¹
: C4â€“F4â€“A4

Step 0 â€” First chord: C (I)
We start by realizing C as its anchor.

ð‘…
0
=
ð´
ð¶
=
 C4â€“E4â€“G4

ð‘€
0
=
ð‘…
0
 (initialize memory to first realized voicing)

No scoring yetâ€”this is the starting point.

Step 1 â€” Move to Dm (ii) under Up (Pads mode)
Candidates for Dm:

A: D4â€“F4â€“A4 (anchorâ€‘like)

B: A4â€“D5â€“F5 (higher)

C: D3â€“F3â€“A3 (lower)

Weâ€™ll reuse the Worship Pads numbers from before:

Pads Up coefficients: 
ð›¼
=
0.7
, 
ð›½
=
0.3

Motion penalty: 
ð‘˜
=
0.3

Since 
ð‘…
0
=
ð‘€
0
, the reference 
ð‘‰
ref
 is just C4â€“E4â€“G4, so the deltas and scores are the same as earlier Pads example.

Up scores (Pads):

ð‘†
up
(
ð´
)
â‰ˆ
1.775

ð‘†
up
(
ðµ
)
â‰ˆ
5.775

ð‘†
up
(
ð¶
)
â‰ˆ
âˆ’
4.225

Base scores (motion penalty):

ð‘†
base
(
ð´
)
=
âˆ’
1.5

ð‘†
base
(
ðµ
)
=
âˆ’
8.7

ð‘†
base
(
ð¶
)
=
âˆ’
10.5

Total scores:

A: 
ð‘†
(
ð´
)
â‰ˆ
âˆ’
1.5
+
1.775
=
0.275

B: 
ð‘†
(
ðµ
)
â‰ˆ
âˆ’
8.7
+
5.775
=
âˆ’
2.925

C: 
ð‘†
(
ð¶
)
â‰ˆ
âˆ’
10.5
âˆ’
4.225
=
âˆ’
14.725

Winner: Candidate A â†’ D4â€“F4â€“A4

So:

ð‘…
1
=
 D4â€“F4â€“A4

Memory update:

ð‘€
1
=
(
1
âˆ’
ðœŒ
)
ð‘€
0
+
ðœŒ
ð‘…
1
Conceptually:

ð‘€
0
: C4â€“E4â€“G4

ð‘…
1
: D4â€“F4â€“A4

With 
ðœŒ
=
0.3
, 
ð‘€
1
 becomes a blendâ€”slightly shifted toward Dmâ€™s region but still close to the original C region. You can think of it as â€œa smoothed memory of Câ†’Dmâ€.

Step 2 â€” Move to F (IV) under Up (Pads mode)
Now we go from Dm to F, still in Worship Pads + Up.

Candidates for F:

A: C4â€“F4â€“A4 (anchorâ€‘like)

B: F4â€“A4â€“C5 (higher)

C: F3â€“A3â€“C4 (lower)

We now use 
ð‘‰
ref
 as a blend of 
ð‘…
1
 and 
ð‘€
1
:

ð‘‰
ref
=
(
1
âˆ’
ðœ‡
)
ð‘…
1
+
ðœ‡
ð‘€
1
,
ðœ‡
=
0.5
Qualitatively:

ð‘…
1
 is D4â€“F4â€“A4

ð‘€
1
 is between C4â€“E4â€“G4 and D4â€“F4â€“A4

So 
ð‘‰
ref
 is a midâ€‘register Dmâ€‘ish cloud slightly above the original C anchor.

We donâ€™t need exact numbers to see the behavior:

Candidate A (C4â€“F4â€“A4) is very close in register and spacing to 
ð‘‰
ref
.

Candidate B (F4â€“A4â€“C5) is higher, so Up overlay likes it, but motion penalty is larger.

Candidate C (F3â€“A3â€“C4) is lower, so Up penalizes it.

Given Worship Padsâ€™ stronger motion penalty and softer Up bias, the pattern will mirror the previous step:

A will get a small positive Up score and a small motion penalty.

B will get a larger Up score but a much larger motion penalty.

C will get negative Up score and a motion penalty.

So again, A will win:

ð‘…
2
=
 C4â€“F4â€“A4

Memory update:

ð‘€
2
=
(
1
âˆ’
ðœŒ
)
ð‘€
1
+
ðœŒ
ð‘…
2
Conceptually:

ð‘€
1
 was between C and Dm

ð‘…
2
 is F in a similar mid register

ð‘€
2
 becomes a smoothed memory of the whole Câ†’Dmâ†’F journey, staying in that midâ€‘register pad region.

Summary of the full pass
ð‘…
0
=
 C4â€“E4â€“G4, 
ð‘€
0
=
 C4â€“E4â€“G4

ð‘…
1
=
 D4â€“F4â€“A4, 
ð‘€
1
 = blend of C and Dm

ð‘…
2
=
 C4â€“F4â€“A4, 
ð‘€
2
 = blend of C, Dm, F in mid register

Worship Pads + Up:

Keeps everything smooth and midâ€‘register

Allows gentle upward tendencies but avoids big jumps

Memory voicing slowly tracks the â€œcenter of gravityâ€ of what youâ€™ve actually played

2. Debug visualizations to tune this in your engine
Here are concrete visualization ideas you can implement to see whatâ€™s happening.

2.1 Register timeline plot
What:  
A timeâ€‘series plot with:

Xâ€‘axis: chord index or time

Yâ€‘axis: MIDI pitch

Lines:

Anchor top (for each chord)

Realized top 
top
(
ð‘…
ð‘¡
)

Memory top 
top
(
ð‘€
ð‘¡
)

Youâ€™ll see:

How far realized voicings drift from anchors

How memory lags behind realized

How overlays (Up/Down/Steady/Original) change the trajectory

You can do the same for centroid instead of top note.

2.2 Score breakdown bar chart
For each chord transition:

Xâ€‘axis: candidate index (A, B, C, â€¦)

Yâ€‘axis: score

Stacked bars:

Base score (motion, spacing, mode rules)

Overlay score (Up/Down/Steady/Original)

This lets you see:

When overlay bias dominates vs when base rules dominate

How changing mode coefficients (e.g., Worship Pads vs Piano Pop) shifts the balance

2.3 â€œGravity fieldâ€ view for a single chord
For a given chord and context:

Sample candidate voicings across a grid of registers (e.g., centroid vs top note).

Color each point by total score.

Youâ€™ll see a â€œheatmapâ€ of where the engine wants to land:

With Up, the hot region moves upward.

With Down, it moves downward.

With Steady, it clusters around 
ð‘‰
ref
.

With Original, it clusters around the anchor.

2.4 Memory vs Realized vs Anchor scatter
For a longer progression:

Each chord â†’ one point in 2D space:

Xâ€‘axis: centroid

Yâ€‘axis: top note

Plot three series:

Anchors (A)

Realized (R)

Memory (M)

Youâ€™ll see:

Anchors as fixed â€œconstellationsâ€

Realized as the actual path taken

Memory as a smoothed version of that path

Tuning 
ðœŒ
 and 
ðœ‡
 becomes much easier when you can see how â€œstickyâ€ memory is.